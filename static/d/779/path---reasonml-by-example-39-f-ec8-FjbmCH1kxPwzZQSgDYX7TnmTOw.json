{"data":{"site":{"siteMetadata":{"title":"My blog","author":"Olek Dubenko"}},"mdx":{"excerpt":"Hi I really want to share with you about this magnificent language  ReasonML . Before we start let me tell you that this is a gentle introduction for peopleâ€¦","code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"ReasonML by example\",\n  \"date\": \"2019-04-21T11:07:16.785Z\",\n  \"description\": \"Facebook team did WHAT?\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Hi\"), mdx(\"p\", null, \"I really want to share with you about this magnificent language \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/\"\n  }), \"ReasonML\"), \".\"), mdx(\"p\", null, \"Before we start let me tell you that this is a gentle introduction for people mainly coming from javascript background (like me). I'm by no means an expert in reason or functional programming and if you are serious about learning reason you should checkout out (after reading this post of course) \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/what-and-why\"\n  }), \"official documentation\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://reasonmlhub.com/exploring-reasonml/toc.html\"\n  }), \"awesome book by Dr Axel Rauschmayer\"), \".\"), mdx(\"h2\", null, \"Intro\"), mdx(\"p\", null, \"Remember when you first chained \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" calls on array in js? Remember how cool you felt when you wrote your first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".reduce((a,b) => a + b)\"), \"? If you're like me than you probably found that writing and composing pure functions\\njust felt 'right'. Writing functional code is very satisfying. And while javascript has some cool functional tricks built-in (like first class functions, closuers, etc) it still has some flaws (who needs both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \"?) and shortcomings that aren't trivial to improve/fix because of that whole \\\"don't break the web\\\" stuff.\"), mdx(\"p\", null, \"To improve experience of writing code that runs on web several compile-to-js languages popped out. Some were succesful and some were not. Today I'll try to show that this language is \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=lzEweA7RPi0\"\n  }), \"serious business\"), \".\"), mdx(\"p\", null, \"ReasonML \\u2014 a functional programming language oriented mainly towards javascript developers. Let's look at some of the benefits it offers:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Compilation to JS\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"It compiles to javascript. Not only it produces mostly readable and performant javascript code but it happens really fast. TypeScript i really love you but damn your builds are slow.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Full-featured battle-tested functional programming language\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"ReasonML is actually OCaml with a different syntax. And while Reason is relatively new project, OCaml is not. It's more than 20 years old language.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sound type system\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"It means that types don't lie to you. \\\"Pure Reason program has no null bugs.\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Familiar syntax\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"You can probably already read it just fine. It looks just like js. (for a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"reason\"), \" \", mdx(\"sup\", null, mdx(\"sub\", null, \"sorry I promise I won't do reason puns\")), \")\"))), mdx(\"h2\", null, \"Show, don't tell\"), mdx(\"p\", null, \"After playing with it I had an urge to write something that I never really liked. I never liked writing tree structures and recursive functions. Oh the sweet memories of juggling with pointers and if statements in c++ to make trees and mental gymnastics to figure out how to write that recursive functions. I hated it. Until I tried Reasonml.\"), mdx(\"p\", null, \"You probably know about N-Body simulation. Also why did everyone still let them get away with naming variables with one letter? And it's different letter every time (look at k-nn!!)\"), mdx(\"p\", null, \"There is this approximation of n-body simulation called Barnes\\u2013Hut simulation. Using it I want to create a interactive playground with potentially large amount of bodies. (Something inspired by falling sand game).\"), mdx(\"p\", null, \"Welcome to my let's write episode 1 of 500.\"), mdx(\"p\", null, \"In this post I'll implement one part of Barnes\\u2013Hut simulation which is spatial quadtree. It is not that complicated as it sounds and just means that it divides 2D space into squares and every node in the tree can have up to 4 children. To do a division of 3D space we would need an octotree.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./quadtree.png\",\n    \"alt\": \"quadtree\"\n  }))), mdx(\"p\", null, \"Walk with me. Process of setting up reason project is described over \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/installation\"\n  }), \"here\"), \" but if you're too lazy to click that here are commands to paste in terminal:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sh\"\n  }), \"yarn global add bs-platform\\nbsb -init my-new-project -theme basic-reason\\n\")), mdx(\"p\", null, \"Also don't forget to grab a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://marketplace.visualstudio.com/items?itemName=jaredly.reason-vscode\"\n  }), \"plugin\"), \" for your favorite editor.\"), mdx(\"p\", null, \"Let's start from the module called Vector.\\nIn Reason every file is a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/module\"\n  }), \"Module\"), \". Module name has to be capitalized.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Vector.re\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type t = {\\n  x: float,\\n  y: float,\\n};\\n\\nlet make = (x, y) => {x, y};\\n\\nlet add = (v1, v2) => {x: v1.x +. v2.x, y: v1.y +. v2.y};\\n\\nlet random = max => make(Js.Math.random() *. max, Js.Math.random() *. max);\\n\")), mdx(\"p\", null, \"Everything from module is available in every part of your program by writing for example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vector.add\"), \". No export/import is needed.\"), mdx(\"p\", null, \"Notice how it has declared \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type t\"), \"? When we want to describe type of vector we would probably call that type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"vector\"), \" right? But we already have a module \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vector\"), \" named like that so in reason there is a convention to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"t\"), \" as a name for main type of the module.\"), mdx(\"p\", null, \"Let's look at function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let make = (x, y) => {x, y};\\n\")), mdx(\"p\", null, \"Can you guess what it does? One thing that you might notice is that there are no types. That beacuse types are inferred (guessed). By looking at current scope reason can notice that there is a type that has the same shape as the return shape \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{x, y}\"), \" and from that type it knows that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \" are floats. Pretty cool, right? And while most of the times it can guess correctly you can still write types yourself.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let make = (x: float, y: float): t => {x, y};\\n\")), mdx(\"p\", null, \"On to the next line! Adding vectors:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let add = (v1, v2) => {x: v1.x +. v2.x, y: v1.y +. v2.y};\\n\")), mdx(\"p\", null, \"Pretty straightforward but wait what are those dots after plus sign? Remember all those jokes from backend devs about how you can write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[]+![]\"), \" and get an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" string in js? Yeah we can't do that in reason. For adding integers there is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"+\"), \" operator and for adding floats there is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"+.\"), \" operator (and it is the same with other math operations). \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/integer-and-float#design-decisions\"\n  }), \"That might change in future\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let random = max => make(Js.Math.random() *. max, Js.Math.random() *. max);\\n\")), mdx(\"p\", null, \"In this function we are calling native js function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.random\"), \" by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Js\"), \" module.\"), mdx(\"p\", null, \"Let's define body as something that has mass and position.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Body.re\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type t = {\\n  mass: float,\\n  pos: Vector.t,\\n};\\n\\nlet make = () => {mass: 10.0, pos: Vector.random(512.0)};\\n\")), mdx(\"p\", null, \"Next, I'll add the module for bounding box. We will construct quadtree out of these squares and we will also need to split them into four equal boxes also called quadrants.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type t = {\\n  topLeft: Vector.t,\\n  side: float,\\n};\\n\")), mdx(\"p\", null, \"Box definition consists of its' top left point and size of the side.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type quadrant =\\n  | NE\\n  | NW\\n  | SE\\n  | SW;\\n\")), mdx(\"p\", null, \"Alright something new. What you see here is called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/variant\"\n  }), \"Variant type\"), \". Marked with an exclamation point in reason documents because of how awesome this thing is.\"), mdx(\"p\", null, \"What we are declaring here is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"quadrant\"), \" is a type that can be either of these values: NE, NW, SE, SW. This is a supersimple example of a variant type but don't judge it as a enum just yet. I'll show more of it later.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let getSubquadrantBbox = (bbox, quadrant) => {\\n  let halfSide = bbox.side /. 2.0;\\n\\n  let topLeftOffset =\\n    switch (quadrant) {\\n    | NW => Vector.make(0.0, 0.0)\\n    | NE => Vector.make(halfSide, 0.0)\\n    | SW => Vector.make(0.0, halfSide)\\n    | SE => Vector.make(halfSide, halfSide)\\n    };\\n\\n  {side: halfSide, topLeft: Vector.add(bbox.topLeft, topLeftOffset)};\\n};\\n\")), mdx(\"p\", null, \"In this function we want to get one of the four possible subquadrants of the box. New size will be exactly half of the current box and then we need to calculate where the new top left point will be. Here the (pattern matching)\", \"[https://reasonml.github.io/docs/en/pattern-matching]\", \" expression is used. In docs it is called \\\"one of the best features of the language\\\" and I agree. In short, concise way it is handling all variants of the quadrant variable. Also it will scream at you if you forget to handle some variant. (Have you ever forgot to handle some action in redux reducer? I sure did) Did you notice that you can assign it to a value?\"), mdx(\"p\", null, \"Last value in the body of the function is returned so we don't need to write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let quadrantFromPoint = (bbox, point: Vector.t) => {\\n  let {topLeft, side} = bbox;\\n  let center = Vector.add(topLeft, Vector.make(side /. 2.0, side /. 2.0));\\n\\n  switch (point.x > center.x, point.y > center.x) {\\n  | (true, true) => SE\\n  | (true, false) => NE\\n  | (false, true) => SW\\n  | (false, false) => SE\\n  };\\n};\\n\")), mdx(\"p\", null, \"In this function we return in which quadrant is the point. A beloved feature in js \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/destructuring\"\n  }), \"destructuring\"), \" is also here.\\nAnd we are using pattern matching on two boolean values because we can.\"), mdx(\"p\", null, \"With Vector, Body and BBox modules done lets write octotree.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Tree.re\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type t = {\\n  body: option(Body.t),\\n  bbox: BBox.t,\\n  ne: option(t),\\n  nw: option(t),\\n  se: option(t),\\n  sw: option(t),\\n};\\n\")), mdx(\"p\", null, \"There is a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"option\"), \" type here. In reason there are no null or undefined and thats great. Instead \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"option\"), \" type is used for values that can be empty. You can skip this if you're familiar with Java Optional type.\"), mdx(\"h3\", null, \"Option\"), mdx(\"p\", null, \"Lets imagine we have a function that searches and maybe returns string as result.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let searchResult = search(); /* Does some search and returns option(string) */\\n\")), mdx(\"p\", null, \"Result can be either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Some(string)\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \".\\nIn fact \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"option\"), \" is just a variant type defined like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"type option('a) = None | Some('a)\\n\")), mdx(\"p\", null, \"Where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'a\"), \" means some type. Similar to T in generics in other languages.\"), mdx(\"p\", null, \"And to handle such value we can use pattern matching.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"switch(searchResult) {\\n  | None => Js.log(\\\"No result :(\\\")\\n  | Some(result) => Js.log(\\\"Result is: \\\"++result)\\n}\\n\")), mdx(\"p\", null, \"In second case we unpacked \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"result\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Some\"), \" value and were forced to handle empty result.\"), mdx(\"p\", null, \"You can read more about Option \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reasonml.github.io/docs/en/null-undefined-option\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"So going back to our tree example. We are defining tree node as record that has a defined bounding box in space, maybe has a body and maybe has four child nodes in four quadrants. This type is recursive.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let make =\\n    (\\n      ~bbox: BBox.t={side: 512.0, topLeft: Vector.make(0.0, 0.0)},\\n      ~body=None,\\n      (),\\n    ) => {\\n  body,\\n  bbox,\\n  ne: None,\\n  nw: None,\\n  se: None,\\n  sw: None,\\n};\\n\")), mdx(\"p\", null, \"Function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make\"), \" creates a tree node. It takes two named parameters. To make a parameter named we put a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"~\"), \" sign before its name. Both of these parameters have default value defined after \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"=\"), \" sign. To make named parameter optional you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"?\"), \" as default value. Ok so why does it have empty brackets as a third parameter? Because of the currying it is unclear what to do with function when using some of the parameters. Should function call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make(~body)\"), \" return new curried function or should it call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"make\"), \" function because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"~bbox\"), \" is optional? For that reason we need to add positional argument (non-labeled) which is conventionally \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"()\"), \".\"), mdx(\"p\", null, \"Like in javascript if field name and value are named the same we can write it once\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let a = {\\n  body: body\\n}\\nlet b ={\\n  body\\n}\\n\")), mdx(\"p\", null, \"Both are the same.\"), mdx(\"p\", null, \"Simple function for returning a child from the node\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let getNode = (tree, quadrant: BBox.quadrant) =>\\n  switch (quadrant) {\\n  | SE => tree.se\\n  | NE => tree.ne\\n  | SW => tree.sw\\n  | NW => tree.nw\\n  };\\n\")), mdx(\"p\", null, \"In this function we define type for the quadrant because it is not in scope. For that we would need to open module like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"open BBox\\n\")), mdx(\"p\", null, \"It will make contents of the module visible in scope (not copied) so we could write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"quadrant\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BBox.quadrant\"), \".\"), mdx(\"p\", null, \"Function for adding a child to a node:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let setNode = (tree: t, where: BBox.quadrant, node: t) =>\\n  switch (where) {\\n  | SE => {...tree, se: Some(node)}\\n  | NE => {...tree, ne: Some(node)}\\n  | SW => {...tree, sw: Some(node)}\\n  | NW => {...tree, nw: Some(node)}\\n  };\\n\")), mdx(\"p\", null, \"Oh yeah, spread operator is also present in Reason!\"), mdx(\"p\", null, \"Function for creating single node:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let createNode = (bbox: BBox.t, quadrant: BBox.quadrant, body: Body.t) => {\\n  let subquadrant = BBox.getSubquadrantBbox(bbox, quadrant);\\n  make(~bbox=subquadrant, ~body=Some(body), ());\\n};\\n\")), mdx(\"p\", null, \"Notice how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"body\"), \" is wrapped in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Some\"), \". Because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"~body\"), \" parameter is of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"option\"), \" we can't just pass the value.\"), mdx(\"p\", null, \"Function for inserting a body intro a tree:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-reason\"\n  }), \"let rec insert = (tree: t, body: Body.t) =>\\n  switch (tree.body) {\\n  | Some(_) =>\\n    let quadrant = BBox.quadrantFromPoint(tree.bbox, body.pos);\\n    let child = getNode(tree, quadrant);\\n\\n    switch (child) {\\n    | Some(node) => insert(node, body)\\n    | None => setNode(tree, quadrant, createNode(tree.bbox, quadrant, body))\\n    };\\n  | None => {...tree, body: Some(body)}\\n  };\\n\")), mdx(\"p\", null, \"Here comes the most interesting part: recursive function for inserting nodes. Look how small it is!! I must admit that this is not first version of this function but after some tries I'm really happy with the result.\"), mdx(\"p\", null, \"In this function we need to find and/or create a node for body. We either find appropriate box with no body or recursively divide space until we do.\"), mdx(\"h2\", null, \"Compiling\"), mdx(\"p\", null, \"After running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bsb -make-world\"), \" it will compile every \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".re\"), \" file to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".bs.js\"), \" and I encourage you to look at the produced code as it is quite readable and interesting. For example options' \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \" value is just an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" how cool is that?\"), mdx(\"h2\", null, \"Next\"), mdx(\"p\", null, \"If we hit 100k likes then I'll try to visualize the quadtree using Canvas API and show you how to do JS interop in the next part.\"));\n}\nMDXContent.isMDXComponent = true;"},"frontmatter":{"title":"ReasonML by example","date":"April 21, 2019","description":"Facebook team did WHAT?"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/reasonml-by-example/","previous":null,"next":{"fields":{"slug":"/life-after-google/"},"frontmatter":{"title":"Life after Google â€” map for your website"},"code":{"scope":""}}}}